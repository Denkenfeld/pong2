<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>HYPER-PONG: ULTIMATE MEDIA-PIPE EDITION</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;900&display=swap');
        body { margin: 0; background: #000; color: #0ff; font-family: 'Orbitron', sans-serif; overflow: hidden; display: flex; flex-direction: column; align-items: center; }
        #game-wrapper { position: relative; margin-top: 50px; }
        canvas { background: #050505; border: 4px solid #0ff; box-shadow: 0 0 60px rgba(0, 255, 255, 0.5); border-radius: 20px; transition: transform 0.1s; }
        #ui { position: absolute; top: -50px; width: 100%; display: flex; justify-content: space-between; font-size: 18px; text-shadow: 0 0 10px #0ff; }
        #video-container { position: fixed; bottom: 20px; left: 20px; width: 180px; height: 135px; border: 2px solid #f0f; border-radius: 10px; overflow: hidden; opacity: 0.6; z-index: 100; box-shadow: 0 0 20px #f0f; }
        #video-preview { width: 100%; height: 100%; transform: scaleX(-1); object-fit: cover; }
        #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; background: rgba(0,0,0,0.95); flex-direction: column; align-items: center; justify-content: center; z-index: 1000; }
        button { background: #0ff; border: none; padding: 20px 40px; font-family: 'Orbitron'; font-weight: bold; cursor: pointer; box-shadow: 0 0 25px #0ff; border-radius: 10px; font-size: 22px; transition: 0.2s; }
        button:hover { transform: scale(1.1); background: #fff; }
        .hp-val { color: #f0f; font-weight: 900; text-shadow: 0 0 15px #f0f; }
        .shake { animation: shakeEffect 0.2s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shakeEffect { 10%, 90% { transform: translate3d(-4px, 0, 0); } 20%, 80% { transform: translate3d(8px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-10px, 0, 0); } 40%, 60% { transform: translate3d(10px, 0, 0); } }
    </style>
</head>
<body>

<div id="game-wrapper">
    <div id="ui">
        <div class="hp-val">P1 HP: <span id="hpL">10</span></div>
        <div style="text-align:center">
            <div style="color:#f7ff00; font-size: 22px;">âš¡ <span id="timer">60</span>s âš¡</div>
            <div id="lvl-ui">STAGE: <span id="lvl">1</span></div>
        </div>
        <div class="hp-val">P2 HP: <span id="hpR">10</span></div>
    </div>
    <canvas id="gameCanvas" width="1000" height="600"></canvas>
    <div id="overlay">
        <h1 id="win-msg" style="color:#f0f; font-size: 60px; text-shadow: 0 0 30px #f0f;">CRITICAL ERROR</h1>
        <button onclick="restartGame()">REBOOT SYSTEM</button>
    </div>
</div>

<div id="video-container"><video id="video-preview" autoplay></video></div>

<script>
/** ðŸ”Š AUDIO ENGINE (Procedural Retro Synth) **/
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playSound(freq, type, duration, vol=0.1) {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    gain.gain.setValueAtTime(vol, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + duration);
}

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const wrapper = document.getElementById('game-wrapper');

let gameActive = true, level = 1, timeLeft = 60, hpL = 10, hpR = 10;
let padL = { y: 250, h: 100, w: 20 }, padR = { y: 250, h: 100, w: 20 };
let balls = [], bricks = [], particles = [];

/** ðŸŽ¨ BRICK PATTERNS (Smiley, Heart, Grid) **/
const patterns = [
    // Smiley
    [[0,1,1,0,0],[1,0,0,1,0],[0,0,0,0,0],[1,0,0,0,1],[0,1,1,1,0]],
    // Heart
    [[0,1,0,1,0],[1,1,1,1,1],[1,1,1,1,1],[0,1,1,1,0],[0,0,1,0,0]],
    // Cross
    [[1,0,0,0,1],[0,1,0,1,0],[0,0,1,0,0],[0,1,0,1,0],[1,0,0,0,1]]
];

/** ðŸ–ï¸ GOOGLE MEDIAPIPE HAND TRACKING **/
const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.7 });
hands.onResults(res => {
    if (res.multiHandLandmarks) {
        res.multiHandLandmarks.forEach(m => {
            let y = m[9].y * 600;
            // Da Kamera gespiegelt: x > 0.5 ist Linke Hand des Nutzers
            if (m[9].x > 0.5) padL.y = y - padL.h/2; else padR.y = y - padR.h/2;
        });
    }
});
new Camera(document.getElementById('video-preview'), {
    onFrame: async () => await hands.send({image: document.getElementById('video-preview')}),
    width: 640, height: 480
}).start();

function createBall(x, y, dx, dy, extra = false) {
    return { x, y, dx, dy, extra, trail: [] };
}

function spawnExplosion(x, y, color) {
    for(let i=0; i<20; i++) {
        particles.push({
            x, y, 
            dx: (Math.random()-0.5)*15, 
            dy: (Math.random()-0.5)*15, 
            life: 1.0, 
            color
        });
    }
}

function initLevel() {
    bricks = [];
    balls = [createBall(500, 300, 7, 4)];
    timeLeft = 60;
    const pat = patterns[Math.floor(Math.random()*patterns.length)];
    const brickW = 40, brickH = 30;
    const offsetX = 500 - (pat[0].length * (brickW + 10)) / 2;
    const offsetY = 300 - (pat.length * (brickH + 10)) / 2;

    for(let r=0; r<pat.length; r++) {
        for(let c=0; c<pat[r].length; c++) {
            if(pat[r][c]) {
                bricks.push({ 
                    x: offsetX + c*(brickW+10), 
                    y: offsetY + r*(brickH+10), 
                    w: brickW, h: brickH, 
                    active: true, 
                    color: `hsl(${Math.random()*360}, 100%, 60%)` 
                });
            }
        }
    }
    playSound(300, 'square', 0.5);
}

// Global Timer Loop
setInterval(() => {
    if(gameActive && --timeLeft <= 0) { level++; initLevel(); }
}, 1000);

function update() {
    if (!gameActive) return;

    for (let i = balls.length - 1; i >= 0; i--) {
        let b = balls[i];
        b.x += b.dx; b.y += b.dy;
        
        // Trail logic
        b.trail.push({x: b.x, y: b.y});
        if(b.trail.length > 15) b.trail.shift();

        // Wall Bounce
        if (b.y < 0 || b.y > 600) {
            b.dy *= -1;
            playSound(600, 'sine', 0.1);
        }

        // Paddle Collision
        if (b.x < 45 && b.y > padL.y && b.y < padL.y+padL.h) {
            b.dx = Math.abs(b.dx) + 0.4;
            b.dy += (Math.random()-0.5)*6;
            playSound(400, 'triangle', 0.15);
        }
        if (b.x > 955 && b.y > padR.y && b.y < padR.y+padR.h) {
            b.dx = -Math.abs(b.dx) - 0.4;
            b.dy += (Math.random()-0.5)*6;
            playSound(400, 'triangle', 0.15);
        }

        // Brick Collision
        bricks.forEach(br => {
            if (br.active && b.x > br.x && b.x < br.x+br.w && b.y > br.y && b.y < br.y+br.h) {
                br.active = false;
                b.dx *= -1.05;
                spawnExplosion(br.x + br.w/2, br.y + br.h/2, br.color);
                playSound(800, 'sawtooth', 0.05);
                // SPAWN EXTRA BALL
                balls.push(createBall(br.x, br.y, -b.dx, (Math.random()-0.5)*10, true));
            }
        });

        // Out of Bounds Logic
        if (b.x < 0 || b.x > 1000) {
            if (b.extra) {
                balls.splice(i, 1);
            } else {
                if (b.x < 0) { hpL--; if(hpR < 10) hpR++; }
                else { hpR--; if(hpL < 10) hpL++; }
                
                playSound(80, 'sawtooth', 0.5, 0.4);
                wrapper.classList.add('shake');
                setTimeout(()=>wrapper.classList.remove('shake'), 300);
                
                if (hpL <= 0 || hpR <= 0) gameActive = false;
                
                // Reset Hauptball in Mitte
                b.x = 500; b.y = 300;
                b.dx = b.x < 0 ? 7 : -7;
                b.dy = (Math.random()-0.5)*10;
                b.trail = [];
            }
        }
    }

    particles.forEach((p, i) => {
        p.x += p.dx; p.y += p.dy; p.life -= 0.02;
        if(p.life <= 0) particles.splice(i, 1);
    });

    if (bricks.length > 0 && bricks.every(b => !b.active)) { level++; initLevel(); }

    document.getElementById('hpL').innerText = hpL;
    document.getElementById('hpR').innerText = hpR;
    document.getElementById('timer').innerText = timeLeft;
    document.getElementById('lvl').innerText = level;

    if(!gameActive) {
        document.getElementById('overlay').style.display = 'flex';
        document.getElementById('win-msg').innerText = hpL <= 0 ? "PLAYER 2 DOMINATED" : "PLAYER 1 DOMINATED";
    }
}

function draw() {
    // Glow effect background
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.fillRect(0,0,1000,600);

    // Balls & Trails
    balls.forEach(b => {
        b.trail.forEach((t, i) => {
            ctx.fillStyle = b.extra ? `rgba(255,255,0,${i/15})` : `rgba(0,255,255,${i/15})`;
            ctx.beginPath(); ctx.arc(t.x, t.y, b.extra ? 4 : 8, 0, Math.PI*2); ctx.fill();
        });
        ctx.shadowBlur = 20;
        ctx.shadowColor = b.extra ? '#ff0' : '#0ff';
        ctx.fillStyle = b.extra ? '#ff0' : '#0ff';
        ctx.beginPath(); ctx.arc(b.x, b.y, b.extra ? 5 : 10, 0, Math.PI*2); ctx.fill();
    });

    // Bricks
    bricks.forEach(br => {
        if(br.active) {
            ctx.shadowBlur = 15; ctx.shadowColor = br.color;
            ctx.fillStyle = br.color;
            ctx.fillRect(br.x, br.y, br.w, br.h);
            ctx.strokeStyle = '#fff'; ctx.strokeRect(br.x, br.y, br.w, br.h);
        }
    });

    // Explosion Particles
    particles.forEach(p => {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, 4, 4);
    });
    ctx.globalAlpha = 1; ctx.shadowBlur = 0;

    // Paddles
    ctx.fillStyle = '#0ff'; ctx.shadowBlur = 20; ctx.shadowColor = '#0ff';
    ctx.fillRect(15, padL.y, padL.w, padL.h);
    ctx.fillStyle = '#f0f'; ctx.shadowColor = '#f0f';
    ctx.fillRect(965, padR.y, padR.w, padR.h);

    update();
    requestAnimationFrame(draw);
}

function restartGame() {
    hpL = 10; hpR = 10; level = 1; gameActive = true;
    document.getElementById('overlay').style.display = 'none';
    initLevel();
}

initLevel();
draw();
</script>
</body>
</html>
